# Get Time and F0 Data from a Polar Annotated TextGrid and Sound Combo
# ====================================================================
# Version 0.0.1
#
# Written for Praat 6.0.40
#
# Antoin Eoin Rodgers
# rodgeran@tcd.ie
# Phonetics and speech Laboratory, Trinity College Dublin
# October 27, 2021
#
# Gets time and F0 data from a Polar Annotated TextGrid and Sound combination.
#
# ABOUT YOUR TEXTGRID
# -------------------
# The textgrid needs to include:
#     1. a syllable tier:     interval tier marking each syllable
#     2. a pitch accent tier: interval tier indicating the each pitch accent
#                             if the text begins "N-", "PN-", these will be
#                             identified as the pitch accent type.
#     3. a points tier        a point tier indicating turning points as per
#                             PoLar annotation.
#     4. a levels tier:       a point tier indicating levels are generated by
#                             PoLaR.
#
# ABOUT THE OUTPUT
# ----------------
# The script will generate a table containing the following information for
# each time point associated with a pitch accent in the sound file:
#     1. file name
#     2. index value for accent in the file.
#     3. index value for the point in the pitch accent
#     4. time (secs) of the point.
#     5. time normalized to the number of syllables in the phrase with
#        the pitch accent
#     6. time normalized to the duration of the pitch accent
#     7. F0 in hertz at the time point
#     8. F0 as a z-score, using the mean and SD for the current pitch accent.
#     9. F0 as a level identified by PoLaR
#
# ABOUT THE USER INTERFACE
# ------------------------
# The option to Get the Time and F0 Data appears under "Polar Data Extraction"
# heading when a textgrid and sound file are selected in the options menu.
#
# Most of the options are fairly self-explanatory, except for the following:
#     1. "Max time delta betwen point and level (ms)"
#                This is the maximum time difference allowed between an
#                annotation in the points tier and an associated annotation in
#                the levels tier.
#                It is a failsafe in case there is no appropriate matching level
#                tier annotation. The user is warned if one cannot be found.
#     2. "Run advanced pitch settings"
#                Checking this brings up the advanced pitch settings.
#     3. "Check pitch contour"
#                Offers the option to check the pitch contour and correct any
#                pitch halving or doubling errors.
#
# NOTES
# -----
# 1. The pitch contour is interpolated to mitigate against undefined F0 values.
# 2. A value of -1 in the F0_level column means no associated level value was
#    found in the textgrid.

# Get Variables
cur_grid = selected("TextGrid")
cur_sound = selected("Sound")
@readVariables: ""


# Run menus
@uiMenu
if run_advanced_pitch_settings
    @advPitchUI
endif

# Run main script
@mainScript

#save variables
@writeVariables: ""

exit

# PROCEDURES
procedure mainScript
    # Creates a table with time and F0 normalised data.
    # F0 normalisation is currently done on a PA by PA basis.
    # Get s and e time of each PA based on "collated" tier.
    selectObject: cur_grid
    file_name$ = selected$("TextGrid")
    temp_grid = Extract one tier: pa_tier
    pa_table = Down to Table: "no", 3, "yes", "no"
    num_pas = Get number of rows
    for i to num_pas
        # get s and e time of PA
        pa_t_s[i] = Get value: i, "tmin"
        pa_t_e[i] = Get value: i, "tmax"
        # get type of PA
        pa_text$ = Get value: i, "text"
        e_of_type = index(pa_text$, "-") - 1
        pa_type$[i] = left$(pa_text$, e_of_type)
    endfor
    plusObject: temp_grid
    Remove

    # Get times of each turning pt in each PA
    selectObject: cur_grid
    for cur_pa to num_pas
        # Get first pt at inside current PA boundaries.
        pa_pt_first = Get high index from time: pts_tier, pa_t_s[cur_pa]
        # Check to see if there is a point at the left PA boundary...
        pa_pt_check = Get nearest index from time: pts_tier, pa_t_s[cur_pa]
        pa_pt_check_t = Get time of point: pts_tier, pa_pt_check
        # ...and use that point if there is.
        if fixed$(pa_pt_check_t, 3) = fixed$(pa_t_s[cur_pa], 3)
            pa_pt_first = pa_pt_check
        endif

        # Get last pt at inside current PA boundaries.
        pa_pt_last = Get low index from time: pts_tier, pa_t_e[cur_pa]
        # Check to see if there is a point at the right PA boundary...
        pa_pt_check = Get nearest index from time: pts_tier, pa_t_e[cur_pa]
        pa_pt_check_t = Get time of point: pts_tier, pa_pt_check
        # ...and use that point if there is.
        if fixed$(pa_pt_check_t, 3) = fixed$(pa_t_e[cur_pa], 3)
            pa_pt_last = pa_pt_check
        endif

        num_pts[cur_pa] = pa_pt_last - pa_pt_first + 1

        # Get time of each point in PA
        for i to num_pts[cur_pa]
            cur_pt = pa_pt_first - 1 + i
            pt_t[cur_pa, i] = Get time of point: pts_tier, cur_pt

            # Check there is a matching Level Tier value
            cur_lvl_pt = Get nearest index from time: lvl_tier, pt_t[cur_pa, i]
            chk_lvl_t = Get time of point: lvl_tier, cur_lvl_pt

            # Warn if there is no matching level tier nearby current point.
            if abs(chk_lvl_t - pt_t[cur_pa, i]) > max_lvl_t_delta
                selectObject: cur_grid
                plusObject: cur_sound
                level[cur_pa, i] = - 1
                cur_time$ = fixed$(pt_t[cur_pa, i], 3)
                warning$ = "No acceptable level tier annotation: point "
                    ... + string$(cur_pt) + " at " + cur_time$ + "s"
                appendInfoLine: warning$
                beginPause: "WARNING"
                comment: warning$
                endPause: "Continue", 1, 0
                selectObject: cur_grid
            else
                cur_level$ = Get label of point: lvl_tier, cur_lvl_pt
                level[cur_pa, i] = number(cur_level$)
            endif
        endfor
    endfor

    # Get syllable normalized times
    for cur_pa to num_pas
        syl_one[cur_pa] = Get interval at time: syl_tier, pa_t_s[cur_pa]
         for cur_pt to num_pts[cur_pa]
            cur_syl_num = Get interval at time: syl_tier, pt_t[cur_pa, cur_pt]

            syl_num[cur_pa, cur_pt] = cur_syl_num - syl_one[cur_pa] + 1

            cur_s_t = Get start time of interval: syl_tier, cur_syl_num
            cur_e_t = Get end time of interval: syl_tier, cur_syl_num
            pt_t_syl_norm[cur_pa, cur_pt] = syl_num[cur_pa, cur_pt] - 1
                                        ... + (pt_t[cur_pa, cur_pt] - cur_s_t)
                                        ... / (cur_e_t - cur_s_t)
         endfor
    endfor

    # Get IP normalized times
    for cur_pa to num_pas
         for cur_pt to num_pts[cur_pa]
            pt_t_pa_norm[cur_pa, cur_pt] = (pt_t[cur_pa, cur_pt] - pa_t_s[cur_pa])
                                        ... / (pa_t_e[cur_pa] - pa_t_s[cur_pa])
         endfor
     endfor

     # Get IP normalized times
    for cur_pa to num_pas
        for cur_pt to num_pts[cur_pa]
            pt_t_pa_norm[cur_pa, cur_pt] = (pt_t[cur_pa, cur_pt] - pa_t_s[cur_pa])
                                       ... / (pa_t_e[cur_pa] - pa_t_s[cur_pa])
        endfor
    endfor

    # Get F0 info
    if check_pitch_contour
        @checkPitch: cur_sound

    else
        selectObject: cur_sound
        pitch_temp = To Pitch (ac): 0, f0_min, max_candidates, "no",
                                ... silence_threshold, voicing_threshold,
                                ... octave_cost, octave_jump_cost, vuv_cost,
                                ... f0_max
        pitch = Interpolate
        removeObject: pitch_temp
    endif


    for cur_pa to num_pas
        f0_mean = Get mean: pa_t_s[cur_pa], pa_t_e[cur_pa], "Hertz"
        f0_SD = Get standard deviation: pa_t_s[cur_pa], pa_t_e[cur_pa], "Hertz"
        for cur_pt to num_pts[cur_pa]
            pt_f0[cur_pa, cur_pt] = Get value at time:
                                    ... pt_t[cur_pa, cur_pt], "Hertz", "linear"
            pt_f0_z[cur_pa, cur_pt] = (pt_f0[cur_pa, cur_pt] - f0_mean) / f0_SD
        endfor
    endfor
    Remove

    cur_row = 0
    my_table = Create Table with column names: file_name$, cur_row,
    ... { "file", "accent", "type", "point",
    ... "t_secs", "t_norm_syl", "t_norm_PA", "F0_Hz", "F0_z_score", "F0_level" }
    for cur_pa to num_pas
        cur_pa$ = pa_type$[cur_pa]
        for cur_pt to num_pts[cur_pa]
           Append row
           cur_row += 1

           cur_t$ = fixed$(pt_t[cur_pa, cur_pt], 3)
           cur_syl_t$ = left$(fixed$(pt_t_syl_norm[cur_pa, cur_pt], 3), 5)
           cur_pa_t$ = left$(fixed$(pt_t_pa_norm[cur_pa, cur_pt], 3), 5)
           cur_f0_Hz$ = fixed$(pt_f0[cur_pa, cur_pt], 0)
           cur_f0_z$ = fixed$(pt_f0_z[cur_pa, cur_pt], 3)
           cur_level = level[cur_pa, cur_pt]

           Set string value: cur_row, "file", file_name$
           Set numeric value: cur_row, "accent", cur_pa
           Set string value: cur_row, "type", pa_type$[cur_pa]
           Set numeric value: cur_row, "point", cur_pt
           Set string value: cur_row, "t_secs", cur_t$
           Set string value: cur_row, "t_norm_syl", cur_syl_t$
           Set string value: cur_row, "t_norm_PA", cur_pa_t$
           Set string value: cur_row, "F0_Hz", cur_f0_Hz$
           Set string value: cur_row, "F0_z_score", cur_f0_z$
           Set numeric value: cur_row, "F0_level", cur_level
       endfor
    endfor

    selectObject: cur_grid
    plusObject: cur_sound
endproc

procedure uiMenu
    okay = 0
    while not okay
        selectObject: cur_grid
        plusObject: cur_sound
        okay = 1
        beginPause: "TextGrid and Pitch Processing"
            comment: "TextGrid Information"
            word: "Syllable tier", syllable_tier$
            word: "Pitch accent tier", pitch_accent_tier$
            word: "Points tier", points_tier$
            word: "Levels tier", levels_tier$
            natural: "Max time delta between point and level (ms)",
            ... max_time_delta_between_point_and_level
            comment: "Pitch Information"
            natural: "Pitch floor", pitch_floor
            natural: "Pitch ceiling", pitch_ceiling
            comment: "Other"
            boolean: "Run advanced pitch settings", run_advanced_pitch_settings
            boolean: "Check pitch contour", check_pitch_contour
        my_choice = endPause: "Exit", "Process", 2, 0
        if my_choice = 1
            exit
        endif

        # Find tier numbers (0 = not found)
        @findTier: "syl_tier", cur_grid, syllable_tier$, 1
        okay = okay * syl_tier
        @findTier: "pa_tier", cur_grid, pitch_accent_tier$, 1
        okay = okay * pa_tier
        @findTier: "lvl_tier", cur_grid, levels_tier$, 0
        okay = okay * lvl_tier
        @findTier: "pts_tier", cur_grid, points_tier$, 0
        okay = okay * lvl_tier

        f0_min = pitch_floor
        f0_max = pitch_ceiling
        max_lvl_t_delta = max_time_delta_between_point_and_level / 1000

        if f0_min > f0_max
            f0_temp = f0_max
            f0_max = f0_min
            f0_min = f0_max
            selectObject: cur_grid
            plusObject: cur_sound
            beginPause: "Swapping min and max F0 values."
            endPause: "OK"
        endif

        max_candidates = max__number_of_candidates
        vuv_cost = voiced___unvoiced_cost
    endwhile
endproc

procedure advPitchUI
    selectObject: cur_grid
    plusObject: cur_sound
	beginPause: "Variables for To Pitch (ac) built-in Praat function"
	# set "To Pitch" variables if not set in @toPitchVariables
		natural: "Max. number of candidates", max__number_of_candidates
		positive: "Silence threshold", silence_threshold
		positive: "Voicing threshold", voicing_threshold
		positive: "Octave cost", octave_cost
		positive: "Octave-jump cost", octave_jump_cost
		positive: "Voiced / unvoiced cost", voiced___unvoiced_cost
	.edit_choice = endPause:
		... "Exit", "Continue", 2, 1
    if .edit_choice = 1
        exit
    endif
    max_candidates = max__number_of_candidates
    vuv_cost = voiced___unvoiced_cost
endproc

procedure readVariables: .directory$
    Read from file: .directory$ + "/variables.bin"
    .num_rows = Get number of rows
    for .i to .num_rows
        .cur_var$ = Get value: .i, "variable"
        .cur_val$ = Get value: .i, "value"
        if right$(.cur_var$, 1) == "$"
            if .cur_val$ == ""
                .cur_val$ = "?"
            endif
            '.cur_var$' = .cur_val$
        else
            '.cur_var$' = '.cur_val$'
        endif
    endfor
    Remove
endproc

procedure writeVariables: .directory$
    Read from file: .directory$ + "/variables.bin"
    .num_rows = Get number of rows
    for .i to .num_rows
        .cur_var$ = Get value: .i, "variable"
        .cur_val$ = Get value: .i, "value"
        if right$(.cur_var$, 1) = "$"
            Set string value: .i, "value", '.cur_var$'
            else
                Set numeric value: .i, "value", '.cur_var$'
            endif
        endfor
        Save as binary file: .directory$ + "/variables.bin"
        Remove
endproc

procedure findTier: .outputVar$, .grid, .tier$, .type
    # Outputs the tier number of '.tier$' in '.grid' or returns 0.
        # .outputVar$ = string containing the name of the output variable.
        # .grid   = object number of TextGrid to be checked.
        # .tier$      = name of the tier being sought.
        # .type       = type of tier (0 = point, 1 = interval)
        #
        # If a tier name of the appropriate type is not found, 0 is returned.
        #
        # Antoin Eoin Rodgers
        # rodgeran@tcd.ie
        # Phonetics and speech Laboratory, Trinity College Dublin

    '.outputVar$' = 0
    selectObject: .grid
    .numTiers = Get number of tiers
    .i = 0
    while .i < .numTiers and '.outputVar$' = 0
        .i += 1
        .curTier$ = Get tier name: .i
        '.outputVar$' = .i * (.curTier$ == .tier$)
    endwhile

    # Check target tier is correct tier type.
    if '.outputVar$'
        .is_interval = Is interval tier: '.outputVar$'
        if (.is_interval != .type)
            '.outputVar$' = 0
        endif
    endif

    # Handle tier name and type exceptions.
    if ('.outputVar$' == 0)
        if .type
            .type$ = "Interval"
        else
            .type$ = "Point"
        endif
        .grid_name$  = selected$("TextGrid")
        selectObject: cur_grid
        plusObject: cur_sound
        beginPause: "Error"
            comment: .type$ + " tier called '" + .tier$ + "' not found."
            .end_pause = endPause: "Continue", 1, 1
        .valid = 0
    endif
endproc

procedure checkPitch: .soundobject
    # create pitch objects
    selectObject: .soundobject
    .pitchTrackOrig = To Pitch (ac): 0.75/f0_min, f0_min, max_candidates, "no",
                                ... silence_threshold, voicing_threshold,
                                ... octave_cost, octave_jump_cost, vuv_cost,
                                ... f0_max
    selectObject: .soundobject
    .soundName$ = selected$("Sound")
    .temp_manip = To Manipulation: 0.01, f0_min, f0_max
    Edit

    # run pitch error check
    beginPause: "Checking the pitch track."
        comment: "Showing the pitch track for your current pitch accent."
        comment: "You can correct any pitch tracking errors you see."
        comment: ""
        comment: "Use: [Pitch] > [Multiply pitch frequencies...] > [Factor]"
        comment: ""
        comment: tab$ + "2  = double pitch"
        comment: tab$ + "0.5 = halve pitch"
    .continue = endPause: "Cancel", "Continue", 2, 0
    .continue = (.continue == 2)
    # end proc if cancel selected
    if .continue
        selectObject: .temp_manip
        .tempPitchTier = Extract pitch tier
        plusObject: .pitchTrackOrig
        .temp_pitch = To Pitch
        selectObject: .tempPitchTier
        plusObject: .temp_manip
        plusObject: .pitchTrackOrig
        Remove
    else
        .temp_pitch = .pitchTrackOrig
        removeObject: .temp_manip
    endif
    selectObject: .temp_pitch
    pitch = Interpolate
    removeObject: .temp_pitch
    selectObject: pitch
endproc
